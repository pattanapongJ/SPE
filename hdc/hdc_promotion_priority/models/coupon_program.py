# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo import api,fields, models, _
from odoo.exceptions import UserError, ValidationError

import ast
import re

class CouponProgram(models.Model):
    _inherit = 'coupon.program'

    valid_product_ids = fields.Many2many(
        'product.product', 
        compute="_compute_valid_products",
        string="Valid Products",    
        store=True
    )
    

    @api.depends('rule_products_domain')
    def _compute_valid_products(self):
        for program in self:
            products = self.env['product.product'].search([])
            program.valid_product_ids = program._get_valid_products(products)

    maximum_use_free_product = fields.Integer(help="Maximum number of free product in which reward can be provided")
    pricelists = fields.Many2many('product.pricelist', string='Pricelists')
    def _compute_program_amount(self, field, currency_to):
        self.ensure_one()
        # ใช้บริษัทแรกใน company_ids หรือบริษัทของผู้ใช้งานเป็นค่าเริ่มต้น
        company = self.company_id[:1] or self.env.company
        return self.currency_id._convert(
            self[field],
            currency_to,
            company,
            fields.Date.today()
        )


    @api.model
    def _get_default_company_ids(self):
        return [(6, 0, self.env.user.company_id.ids)]

    company_id = fields.Many2many(
        'res.company',
        string="Companies",
        default=_get_default_company_ids,required=True,
        help="Allow this promotion to apply to multiple companies."
    )
    sale_team_ids = fields.Many2many(
        'crm.team',
        string="Sales Teams",
        help="Restrict this promotion to specific sales teams."
    )
         
    def _filter_programs_on_products(self, order):
        order_lines = order.order_line.filtered(lambda line: line.product_id) - order._get_reward_lines()
        products = order_lines.mapped('product_id')
        products_qties = dict.fromkeys(products, 0)
        for line in order_lines:
            products_qties[line.product_id] += line.product_uom_qty
        valid_program_ids = list()
        for program in self:
            if not program.rule_products_domain or program.rule_products_domain == "[]":
                valid_program_ids.append(program.id)
                continue
            valid_products = program._get_valid_products(products)
            if not valid_products:
                continue
            ordered_rule_products_qty = sum(products_qties[product] for product in valid_products)
            if ordered_rule_products_qty >= program.rule_min_quantity:
                valid_program_ids.append(program.id)
        return self.browse(valid_program_ids)
    
    @api.model
    def _filter_programs_from_common_rules(self, order, next_order=False):
        """ Return the programs if every conditions is met
            :param bool next_order: is the reward given from a previous order
        """
        programs = self
        # Minimum requirement should not be checked if the coupon got generated by a promotion program (the requirement should have only be checked to generate the coupon)
        if not next_order:
            programs = programs and programs._filter_on_mimimum_amount(order)
        if not self.env.context.get("no_outdated_coupons"):
            programs = programs and programs._filter_on_validity_dates(order)
        programs = programs and programs._filter_unexpired_programs(order)
        programs = programs and programs._filter_programs_on_partners(order)
        # Product requirement should not be checked if the coupon got generated by a promotion program (the requirement should have only be checked to generate the coupon)
        if not next_order:
            programs = programs and programs._filter_programs_on_products(order)

        programs_curr_order = programs.filtered(lambda p: p.promo_applicability == 'on_current_order')
        programs = programs.filtered(lambda p: p.promo_applicability == 'on_next_order')
        if programs_curr_order:
            # Checking if rewards are in the SO should not be performed for rewards on_next_order
            programs += programs_curr_order._filter_not_ordered_reward_programs(order)
        return programs
    
    def _filter_not_ordered_reward_programs(self, order):
        """
        Returns the programs when the reward is actually in the order lines
        """
        programs = self.env['coupon.program']
        order_products = order.order_line.product_id
        for program in self:
            # if program.reward_type == 'product' and program.reward_product_id not in order_products:
            #     continue
            if (
                program.reward_type == 'discount'
                and program.discount_apply_on == 'specific_products'
                and not any(discount_product in order_products for discount_product in program.discount_specific_product_ids)
            ):
                continue
            programs += program
        return programs
    
    def _check_promo_code(self, order, coupon_code):
        rec = super(CouponProgram, self)._check_promo_code(order,coupon_code)
        if self.promo_applicability == 'on_current_order' and self.reward_type == 'product':
            rec = {}
        return rec

    @api.onchange('formula_discount','discount_type')
    def _onchange_formula_discount(self):
        if self.discount_type == 'formula' and self.formula_discount:
            discounts = self.formula_discount.replace(" ", "").split("+")
            pattern = re.compile(r'^\d+(\.\d+)?%$|^\d+(\.\d+)?$')
            for discount in discounts:
                if not pattern.match(discount):
                    # self.formula_discount = False
                    raise ValidationError(_('Invalid Discount format : 20%+100 or 100'))

class CouponReward(models.Model):
    _inherit = 'coupon.reward'
    
    discount_type = fields.Selection(
        selection_add=[('formula', 'Formula')]
    )
    formula_discount = fields.Char(string="Formula Discount",help="สูตรสำหรับคำนวณส่วนลด")
    formula_discount_string = fields.Char(string="Formula Discount String",compute="_compute_formula_discount_string",store=True)
    @api.depends('formula_discount','discount_type','reward_type')
    def _compute_formula_discount_string(self):
        for record in self:
            if record.reward_type == 'discount':
                if record.discount_type == 'formula' and record.formula_discount:
                    record.formula_discount_string = record.formula_discount
                elif record.discount_type == 'percentage' and record.discount_percentage:
                    record.formula_discount_string = f"{record.discount_percentage:.2f}%"
                elif record.discount_type == 'fixed_amount' and record.discount_fixed_amount:
                    record.formula_discount_string = str(record.discount_fixed_amount)
                else:
                    record.formula_discount_string = False
            else:
                record.formula_discount_string = False
            

